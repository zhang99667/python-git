[TOC]

# 廖雪峰 - 数据类型和变量

### 数据类型

计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：

#### 整数

Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：`1`，`100`，`-8080`，`0`，等等。

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用`0x`前缀和0-9，a-f表示，例如：`0xff00`，`0xa5b4c3d2`，等等。

对于很大的数，例如`10000000000`，很难数清楚0的个数。Python允许在数字中间以`_`分隔，因此，写成`10_000_000_000`和`10000000000`是完全一样的。十六进制数也可以写成`0xa1b2_c3d4`。

#### 浮点数

浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如`1.23`，`3.14`，`-9.01`，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是`1.23e9`，或者`12.3e8`，0.000012可以写成`1.2e-5`，等等。

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

#### 字符串

字符串是以单引号`'`或双引号`"`括起来的任意文本，比如`'abc'`，`"xyz"`等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。如果`'`本身也是一个字符，那就可以用`""`括起来，比如`"I'm OK"`包含的字符是`I`，`'`，`m`，空格，`O`，`K`这6个字符。

如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识，比如：

```python
'I\'m \"OK\"!'
```

表示的字符串内容是：

```python
I'm "OK"!
```

转义字符`\`可以转义很多字符，比如`\n`表示换行，`\t`表示制表符，字符`\`本身也要转义，所以`\\`表示的字符就是`\`，可以在Python的交互式命令行用`print()`打印字符串看看：

```python
>>> print('I\'m ok.')
I'm ok.
>>> print('I\'m learning\nPython.')
I'm learning
Python.
>>> print('\\\n\\')
\
\
```

如果字符串里面有很多字符都需要转义，就需要加很多`\`，为了简化，Python还允许用`r''`表示`''`内部的字符串默认不转义，可以自己试试：

```python
>>> print('\\\t\\')
\       \
>>> print(r'\\\t\\')
\\\t\\
```

如果字符串内部有很多换行，用`\n`写在一行里不好阅读，为了简化，Python允许用`'''...'''`的格式表示多行内容，可以自己试试：

```python
>>> print('''line1
... line2
... line3''')
line1
line2
line3
```

上面是在交互式命令行内输入，注意在输入多行内容时，提示符由`>>>`变为`...`，提示你可以接着上一行输入，注意`...`是提示符，不是代码的一部分：

```python
┌────────────────────────────────────────────────────────┐
│Command Prompt - python                           _ □ x │
├────────────────────────────────────────────────────────┤
│>>> print('''line1                                      │
│... line2                                               │
│... line3''')                                           │
│line1                                                   │
│line2                                                   │
│line3                                                   │
│                                                        │
│>>> _                                                   │
│                                                        │
│                                                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

当输入完结束符`````和括号`)`后，执行该语句并打印结果。

如果写成程序并存为`.py`文件，就是：

```python
print('''line1
line2
line3''')
```

多行字符串`'''...'''`还可以在前面加上`r`使用，请自行测试：

```python
print(r'''hello,\n
world''')
```

**输出结果：**

> hello,\n
> world

#### 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写），也可以通过布尔运算计算出来：

```
>>> True
True
>>> False
False
>>> 3 > 2
True
>>> 3 > 5
False
```

布尔值可以用`and`、`or`和`not`运算。

`and`运算是与运算，只有所有都为`True`，`and`运算结果才是`True`：

```
>>> True and True
True
>>> True and False
False
>>> False and False
False
>>> 5 > 3 and 3 > 1
True
```

`or`运算是或运算，只要其中有一个为`True`，`or`运算结果就是`True`：

```
>>> True or True
True
>>> True or False
True
>>> False or False
False
>>> 5 > 3 or 1 > 3
True
```

`not`运算是非运算，它是一个单目运算符，把`True`变成`False`，`False`变成`True`：

```
>>> not True
False
>>> not False
True
>>> not 1 > 2
True
```

布尔值经常用在条件判断中，比如：

```
if age >= 18:
    print('adult')
else:
    print('teenager')
```

#### 空值

空值是Python里一个特殊的值，用`None`表示。`None`不能理解为`0`，因为`0`是有意义的，而`None`是一个特殊的空值。

此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。

### 变量

变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和`_`的组合，且不能用数字开头，比如：

```
a = 1
```

变量`a`是一个整数。

```
t_007 = 'T007'
```

变量`t_007`是一个字符串。

```
Answer = True
```

变量`Answer`是一个布尔值`True`。

在Python中，等号`=`是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：

```python
a = 123 # a是整数
print(a)
a = 'ABC' # a变为字符串
print(a)
```

**输出结果：**

> 123
> ABC

这种变量本身类型不固定的语言称之为*动态语言*，与之对应的是*静态语言*。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：

```
int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量
```

和静态语言相比，动态语言更灵活，就是这个原因。

请不要把赋值语句的等号等同于数学的等号。比如下面的代码：

```
x = 10
x = x + 2
```

如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果`12`，再赋给变量`x`。由于`x`之前的值是`10`，重新赋值后，`x`的值变成`12`。

最后，理解变量在计算机内存中的表示也非常重要。当我们写：

```
a = 'ABC'
```

时，Python解释器干了两件事情：

1. 在内存中创建了一个`'ABC'`的字符串；
2. 在内存中创建了一个名为`a`的变量，并把它指向`'ABC'`。

也可以把一个变量`a`赋值给另一个变量`b`，这个操作实际上是把变量`b`指向变量`a`所指向的数据，例如下面的代码：

```python
a = 'ABC'
b = a
a = 'XYZ'
print(b)
```

> ABC

最后一行打印出变量`b`的内容到底是`'ABC'`呢还是`'XYZ'`？如果从数学意义上理解，就会错误地得出`b`和`a`相同，也应该是`'XYZ'`，但实际上`b`的值是`'ABC'`，让我们一行一行地执行代码，就可以看到到底发生了什么事：

执行`a = 'ABC'`，解释器创建了字符串`'ABC'`和变量`a`，并把`a`指向`'ABC'`：

![py-var-code-1](https://www.liaoxuefeng.com/files/attachments/923791878255456/0)

执行`b = a`，解释器创建了变量`b`，并把`b`指向`a`指向的字符串`'ABC'`：

![py-var-code-2](https://www.liaoxuefeng.com/files/attachments/923792058613440/0)

执行`a = 'XYZ'`，解释器创建了字符串'XYZ'，并把`a`的指向改为`'XYZ'`，但`b`并没有更改：

![py-var-code-3](https://www.liaoxuefeng.com/files/attachments/923792191637760/0)

所以，最后打印变量`b`的结果自然是`'ABC'`了。

### 常量

所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：

```
PI = 3.14159265359
```

但事实上`PI`仍然是一个变量，Python根本没有任何机制保证`PI`不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量`PI`的值，也没人能拦住你。

最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是`/`：

```
>>> 10 / 3
3.3333333333333335
```

`/`除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

```
>>> 9 / 3
3.0
```

还有一种除法是`//`，称为地板除，两个整数的除法仍然是整数：

```
>>> 10 // 3
3
```

你没有看错，整数的地板除`//`永远是整数，即使除不尽。要做精确的除法，使用`/`就可以。

因为`//`除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：

```
>>> 10 % 3
1
```

无论整数做`//`除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

### 练习

请打印出以下变量的值：

```python
n = 123
f = 456.789
s1 = 'Hello, world'
s2 = 'Hello, \'Adam\'' # \'转义字符 输出 '
s3 = r'Hello, "Bart"' # 允许用 r' 表示不转义字符
s4 = r'''Hello, 
Lisa!''' # 允许使用 '''...''' 表示多行内容
```

> Hello, world
> Hello, 'Adam'
> Hello, "Bart"
> Hello,
> Lisa!

### 小结

Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。

对变量赋值`x = y`是把变量`x`指向真正的对象，该对象是变量`y`所指向的。随后对变量`y`的赋值*不影响*变量`x`的指向。

注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在`-2147483648`-`2147483647`。

Python的浮点数也没有大小限制，但是超出一定范围就直接表示为`inf`（无限大）。

---

### 1. 变量的引用

1.调用函数时，本质上调用的是实参的引用

![image-20220521215022122](assets\image-20220521215022122.png)

2.将字符串变量返回，返回的是数据的引用，而不是数据本身

### 2. 可变和不可变类型

**不可变类型，**内存中的数据不允许被修改：【改变数据地址会变】

- 数字类型 `int`,`bool`,`float`,`complex`,`long(2.x)`
- 字符串 `str`
- 元组 `tuple`

**可变类型，**内存中的数据可以被修改【相当于改变列表中的数据的地址】：

- 列表 `list`
- 字典 `dict`

***注意：字典的 `key` 只能使用不可变类型的数据***

1.**可变类型**的数据变化，是通过 **方法** 来实现的
2.如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**

- 变量不再对之前的数据引用
- 变量改为对新赋值的数据引用

列表：

<img src="assets\image-20220522122524918.png" alt="image-20220522122524918" style="zoom: 50%;" />

字典：

<img src="assets\image-20220522122741269.png" alt="image-20220522122741269" style="zoom:50%;" />

### 3. 局部变量和全局变量

- 局部变量：在函数内部定义的变量，只能在函数内部使用
- 全局变量：在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量

***提示：在其他的开发语言中，大多不推荐使用全局变量——可变范围太大，导致程序不好维护！***

#### 3.1 局部变量

- **局部变量 **是在 **函数内部** 定义的变量，只能在函数内部使用
- 函数执行结束后，函数内部的局部变量，会 **被系统回收**
- 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响

##### 局部变量的作用

- 在函数内部使用，临时保存函数内部需要使用的数据

##### 局部变量的生命周期

- 所谓 **生命周期** 就是变量从 **被创建** 到 **被系统回收** 的过程
- **局部变量** 在 **函数执行** 时才会被创建
- **函数** 执行结束后局部变量 **被系统回收**
- **局部变量** 在生命周期内，可以用来存储 **函数内部临时使用到的数据**

#### 3.2 全局变量

- 首先查找函数内部是否存在指定名称的局部变量，如果有，直接使用
- 如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用
- 如果还没有，程序报错！

##### 1) 函数不能直接修改全局变量的引用

- 全局变量是在函数外部定义的变量（没有定义在某一个函数内），所有函数内部都可以使用这个变量
- 在函数内部，可以 **通过全局变量** 的引用获取对应的数据
- 但是，**不允许直接修改全局变量的引用**  ——  使用赋值语句修改全局变量的值【如果使用赋值语句，会在函数内部，定义一个局部变量】

##### 2) 在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

##### 3) 全局变量的位置

<img src="assets\image-20220522133213271.png" alt="image-20220522133213271" style="zoom: 50%;" />

##### 4) 全局变量命名的建议

- 为了避免局部变畫和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：
- 全局变量名前应该增加 `g` 或者 `g_` 的前缀

---

# 廖雪峰 - 字符串和编码

### 字符编码

我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。

因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是`65535`，4个字节可以表示的最大整数是`4294967295`。

由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为`ASCII`编码，比如大写字母`A`的编码是`65`，小写字母`z`的编码是`122`。

但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了`GB2312`编码，用来把中文编进去。

你可以想得到的是，全世界有上百种语言，日本把日文编到`Shift_JIS`里，韩国把韩文编到`Euc-kr`里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。

![char-encoding-problem](https://www.liaoxuefeng.com/files/attachments/923930471927008/0)

因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。

Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。

现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。

字母`A`用ASCII编码是十进制的`65`，二进制的`01000001`；

字符`0`用ASCII编码是十进制的`48`，二进制的`00110000`，注意字符`'0'`和整数`0`是不同的；

汉字`中`已经超出了ASCII编码的范围，用Unicode编码是十进制的`20013`，二进制的`01001110 00101101`。

你可以猜测，如果把ASCII编码的`A`用Unicode编码，只需要在前面补0就可以，因此，`A`的Unicode编码是`00000000 01000001`。

新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的`UTF-8`编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

| 字符 | ASCII    | Unicode           | UTF-8                      |
| :--- | :------- | :---------------- | :------------------------- |
| A    | 01000001 | 00000000 01000001 | 01000001                   |
| 中   | x        | 01001110 00101101 | 11100100 10111000 10101101 |

从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：

在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。

用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：

![rw-file-utf-8](https://www.liaoxuefeng.com/files/attachments/923923787018816/0)

浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：

![web-utf-8](https://www.liaoxuefeng.com/files/attachments/923923759189600/0)

所以你看到很多网页的源码上会有类似`<meta charset="UTF-8" />`的信息，表示该网页正是用的UTF-8编码。

### Python的字符串

搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。

在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：

```
>>> print('包含中文的str')
包含中文的str
```

对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符：

```
>>> ord('A')
65
>>> ord('中')
20013
>>> chr(66)
'B'
>>> chr(25991)
'文'
```

如果知道字符的整数编码，还可以用十六进制这么写`str`：

```
>>> '\u4e2d\u6587'
'中文'
```

两种写法完全是等价的。

由于Python的字符串类型是`str`，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以字节为单位的`bytes`。

Python对`bytes`类型的数据用带`b`前缀的单引号或双引号表示：

```
x = b'ABC'
```

要注意区分`'ABC'`和`b'ABC'`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。

以Unicode表示的`str`通过`encode()`方法可以编码为指定的`bytes`，例如：

```
>>> 'ABC'.encode('ascii')
b'ABC'
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'
>>> '中文'.encode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
```

纯英文的`str`可以用`ASCII`编码为`bytes`，内容是一样的，含有中文的`str`可以用`UTF-8`编码为`bytes`。含有中文的`str`无法用`ASCII`编码，因为中文编码的范围超过了`ASCII`编码的范围，Python会报错。

在`bytes`中，无法显示为ASCII字符的字节，用`\x##`显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是`bytes`。要把`bytes`变为`str`，就需要用`decode()`方法：

```
>>> b'ABC'.decode('ascii')
'ABC'
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'
```

如果`bytes`中包含无法解码的字节，`decode()`方法会报错：

```
>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
Traceback (most recent call last):
  ...
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
```

如果`bytes`中只有一小部分无效的字节，可以传入`errors='ignore'`忽略错误的字节：

```
>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
'中'
```

要计算`str`包含多少个字符，可以用`len()`函数：

```
>>> len('ABC')
3
>>> len('中文')
2
```

`len()`函数计算的是`str`的字符数，如果换成`bytes`，`len()`函数就计算字节数：

```
>>> len(b'ABC')
3
>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
6
>>> len('中文'.encode('utf-8'))
6
```

可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

在操作字符串时，我们经常遇到`str`和`bytes`的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对`str`和`bytes`进行转换。

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

申明了UTF-8编码并不意味着你的`.py`文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：

![set-encoding-in-notepad++](https://www.liaoxuefeng.com/files/attachments/1008802356788736)

如果`.py`文件本身使用UTF-8编码，并且也申明了`# -*- coding: utf-8 -*-`，打开命令提示符测试就可以正常显示中文：

![py-chinese-test-in-cmd](https://www.liaoxuefeng.com/files/attachments/1008802515054144)

### 格式化

最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似`'亲爱的xxx你好！你xx月的话费是xx，余额是xx'`之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。

![py-str-format](https://www.liaoxuefeng.com/files/attachments/928817906446432/0)

在Python中，采用的格式化方式和C语言是一致的，用`%`实现，举例如下：

```
>>> 'Hello, %s' % 'world'
'Hello, world'
>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
'Hi, Michael, you have $1000000.'
```

你可能猜到了，`%`运算符就是用来格式化字符串的。在字符串内部，`%s`表示用字符串替换，`%d`表示用整数替换，有几个`%?`占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个`%?`，括号可以省略。

常见的占位符有：

| 占位符 | 替换内容     |
| :----- | :----------- |
| %d     | 整数         |
| %f     | 浮点数       |
| %s     | 字符串       |
| %x     | 十六进制整数 |

其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：

```python
print('%2d-%02d' % (3, 1))
print('%.2f' % 3.1415926)
```

>  3-01
> 3.14

如果你不太确定应该用什么，`%s`永远起作用，它会把任何数据类型转换为字符串：

```
>>> 'Age: %s. Gender: %s' % (25, True)
'Age: 25. Gender: True'
```

有些时候，字符串里面的`%`是一个普通字符怎么办？这个时候就需要转义，用`%%`来表示一个`%`：

```
>>> 'growth rate: %d %%' % 7
'growth rate: 7 %'
```

### format()

另一种格式化字符串的方法是使用字符串的`format()`方法，它会用传入的参数依次替换字符串内的占位符`{0}`、`{1}`……，不过这种方式写起来比%要麻烦得多：

```
>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'
```

### f-string

最后一种格式化字符串的方法是使用以`f`开头的字符串，称之为`f-string`，它和普通字符串不同之处在于，字符串如果包含`{xxx}`，就会以对应的变量替换：

```
>>> r = 2.5
>>> s = 3.14 * r ** 2
>>> print(f'The area of a circle with radius {r} is {s:.2f}')
The area of a circle with radius 2.5 is 19.62
```

上述代码中，`{r}`被变量`r`的值替换，`{s:.2f}`被变量`s`的值替换，并且`:`后面的`.2f`指定了格式化参数（即保留两位小数），因此，`{s:.2f}`的替换结果是`19.62`。

### 练习

小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出`'xx.x%'`，只保留小数点后1位：

```python
s1 = 72
s2 = 85
"""代码如下："""
r = 100*(s2 -s1)/s1
print('小明成绩提升的百分点：%.1f%%' % r)
print('小明成绩提升的百分点：{0:.1f}%%'.format(r))
```

> 小明成绩提升的百分点：18.06%
> 小明成绩提升的百分点：18.06%%

### 小结

Python 3的字符串使用Unicode，直接支持多语言。

当`str`和`bytes`互相转换时，需要指定编码。最常用的编码是`UTF-8`。Python当然也支持其他编码方式，比如把Unicode编码成`GB2312`：

```
>>> '中文'.encode('gb2312')
b'\xd6\xd0\xce\xc4'
```

但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用`UTF-8`编码。

格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。

---

# 廖雪峰 - 使用 list 和 tuple

### list

Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。

比如，列出班里所有同学的名字，就可以用一个list表示：

```python
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']
```

变量`classmates`就是一个list。用`len()`函数可以获得list元素的个数：

```python
>>> len(classmates)
3
```

用索引来访问list中每一个位置的元素，记得索引是从`0`开始的：

```python
>>> classmates[0]
'Michael'
>>> classmates[1]
'Bob'
>>> classmates[2]
'Tracy'
>>> classmates[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

当索引超出了范围时，Python会报一个`IndexError`错误，所以，要确保索引不要越界，记得最后一个元素的索引是`len(classmates) - 1`。

如果要取最后一个元素，除了计算索引位置外，还可以用`-1`做索引，直接获取最后一个元素：

```python
>>> classmates[-1]
'Tracy'
```

以此类推，可以获取倒数第2个、倒数第3个：

```python
>>> classmates[-2]
'Bob'
>>> classmates[-3]
'Michael'
>>> classmates[-4]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

当然，倒数第4个就越界了。

list是一个可变的有序表，所以，可以往list中追加元素到末尾：

```python
>>> classmates.append('Adam')
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']
```

也可以把元素插入到指定的位置，比如索引号为`1`的位置：

```python
>>> classmates.insert(1, 'Jack')
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
```

要删除list末尾的元素，用`pop()`方法：

```python
>>> classmates.pop()
'Adam'
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']
```

要删除指定位置的元素，用`pop(i)`方法，其中`i`是索引位置：

```python
>>> classmates.pop(1)
'Jack'
>>> classmates
['Michael', 'Bob', 'Tracy']
```

要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：

```python
>>> classmates[1] = 'Sarah'
>>> classmates
['Michael', 'Sarah', 'Tracy']
```

list里面的元素的数据类型也可以不同，比如：

```python
>>> L = ['Apple', 123, True]
```

list元素也可以是另一个list，比如：

```python
>>> s = ['python', 'java', ['asp', 'php'], 'scheme']
>>> len(s)
4
```

要注意`s`只有4个元素，其中`s[2]`又是一个list，如果拆开写就更容易理解了：

```python
>>> p = ['asp', 'php']
>>> s = ['python', 'java', p, 'scheme']
```

要拿到`'php'`可以写`p[1]`或者`s[2][1]`，因此`s`可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。

如果一个list中一个元素也没有，就是一个空的list，它的长度为0：

```python
>>> L = []
>>> len(L)
0
```

### tuple

另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：

```
>>> classmates = ('Michael', 'Bob', 'Tracy')
```

现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用`classmates[0]`，`classmates[-1]`，但不能赋值成另外的元素。

不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：

```
>>> t = (1, 2)
>>> t
(1, 2)
```

如果要定义一个空的tuple，可以写成`()`：

```
>>> t = ()
>>> t
()
```

但是，要定义一个只有1个元素的tuple，如果你这么定义：

```
>>> t = (1)
>>> t
1
```

定义的不是tuple，是`1`这个数！这是因为括号`()`既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是`1`。

所以，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义：

```
>>> t = (1,)
>>> t
(1,)
```

Python在显示只有1个元素的tuple时，也会加一个逗号`,`，以免你误解成数学计算意义上的括号。

最后来看一个“可变的”tuple：

```
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
```

这个tuple定义的时候有3个元素，分别是`'a'`，`'b'`和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？

别急，我们先看看定义的时候tuple包含的3个元素：

![tuple-0](https://www.liaoxuefeng.com/files/attachments/923973516787680/0)

当我们把list的元素`'A'`和`'B'`修改为`'X'`和`'Y'`后，tuple变为：

![tuple-1](https://www.liaoxuefeng.com/files/attachments/923973647515872/0)

表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向`'a'`，就不能改成指向`'b'`，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。

### 练习

请用索引取出下面list的指定元素：

```python
L = [
    ['Apple', 'Google', 'Microsoft'],
    ['Java', 'Python', 'Ruby', 'PHP'],
    ['Adam', 'Bart', 'Lisa']
]
"""代码如下："""
# 打印Apple:
print(L[0][0])
# 打印Python:
print([1][1])
# 打印Lisa:
print([-1][-1])
```

 请问以下变量哪些是tuple类型：

- [ ]  a = ()
- [ ]  b = (1)
- [ ]  c = [2]
- [ ]  d = (3,)
- [ ]  e = (4,5,6)

### 小结

list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。

---

# 廖雪峰 - 条件判断

### 条件判断

计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。

比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用`if`语句实现：

```
age = 20
if age >= 18:
    print('your age is', age)
    print('adult')
```

根据Python的缩进规则，如果`if`语句判断是`True`，就把缩进的两行print语句执行了，否则，什么也不做。

也可以给`if`添加一个`else`语句，意思是，如果`if`判断是`False`，不要执行`if`的内容，去把`else`执行了：

```
age = 3
if age >= 18:
    print('your age is', age)
    print('adult')
else:
    print('your age is', age)
    print('teenager')
```

注意不要少写了冒号`:`。

当然上面的判断是很粗略的，完全可以用`elif`做更细致的判断：

```
age = 3
if age >= 18:
    print('adult')
elif age >= 6:
    print('teenager')
else:
    print('kid')
```

`elif`是`else if`的缩写，完全可以有多个`elif`，所以`if`语句的完整形式就是：

```
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

`if`语句执行有个特点，它是从上往下判断，如果在某个判断上是`True`，把该判断对应的语句执行后，就忽略掉剩下的`elif`和`else`，所以，请测试并解释为什么下面的程序打印的是`teenager`：

```
age = 20
if age >= 6:
    print('teenager')
elif age >= 18:
    print('adult')
else:
    print('kid')
```

`if`判断条件还可以简写，比如写：

```
if x:
    print('True')
```

只要`x`是非零数值、非空字符串、非空list等，就判断为`True`，否则为`False`。

### 再议 input

最后看一个有问题的条件判断。很多同学会用`input()`读取用户的输入，这样可以自己输入，程序运行得更有意思：

```
birth = input('birth: ')
if birth < 2000:
    print('00前')
else:
    print('00后')
```

输入`1982`，结果报错：

```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unorderable types: str() > int()
```

这是因为`input()`返回的数据类型是`str`，`str`不能直接和整数比较，必须先把`str`转换成整数。Python提供了`int()`函数来完成这件事情：

```
s = input('birth: ')
birth = int(s)
if birth < 2000:
    print('00前')
else:
    print('00后')
```

再次运行，就可以得到正确地结果。但是，如果输入`abc`呢？又会得到一个错误信息：

```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'abc'
```

原来`int()`函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。

如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。

### 练习

小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：

- 低于18.5：过轻
- 18.5-25：正常
- 25-28：过重
- 28-32：肥胖
- 高于32：严重肥胖

用`if-elif`判断并打印结果：

```python
height = 1.75
weight = 80.5
"""代码如下："""
bmi = weight / height ** 2

if bmi < 18.5:
    print('小明体重bmi指数为%.3f,过轻' %(bmi) )
elif bmi >= 18.5 and bmi < 25:
    print('小明体重bmi指数为%.3f,正常' %(bmi))
elif bmi >= 25 and bmi < 28:
    print('小明体重bmi指数为%.3f,过重' %(bmi))
elif bmi >= 28 and bmi < 32:
    print('小明体重bmi指数为%.3f,肥胖' %(bmi))
else:
    print('小明体重bmi指数为%.3f,严重肥胖' %(bmi))
```

----

# 廖雪峰 - 循环

### 循环

要计算1+2+3，我们可以直接写表达式：

```
>>> 1 + 2 + 3
6
```

要计算1+2+3+...+10，勉强也能写出来。

但是，要计算1+2+3+...+10000，直接写表达式就不可能了。

为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。

Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：

```
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
```

执行这段代码，会依次打印`names`的每一个元素：

```
Michael
Bob
Tracy
```

所以`for x in ...`循环就是把每个元素代入变量`x`，然后执行缩进块的语句。

再比如我们想计算1-10的整数之和，可以用一个`sum`变量做累加：

```
sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x
print(sum)
```

如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。比如`range(5)`生成的序列是从0开始小于5的整数：

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

`range(101)`就可以生成0-100的整数序列，计算如下：

```python
sum = 0
for x in range(101):
    sum = sum + x
print(sum)
```

> 5050

请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。

第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：

```
sum = 0
n = 99
while n > 0:
    sum = sum + n
    n = n - 2
print(sum)
```

在循环内部变量`n`不断自减，直到变为`-1`时，不再满足while条件，循环退出。

### 练习

请利用循环依次对list中的每个名字打印出`Hello, xxx!`：

```python
L = ['Bart', 'Lisa', 'Adam']
"""代码如下："""
for name in L:
    print("hello",name)
```

> hello Bart
> hello Lisa
> hello Adam

### break

在循环中，`break`语句可以提前退出循环。例如，本来要循环打印1～100的数字：

```
n = 1
while n <= 100:
    print(n)
    n = n + 1
print('END')
```

上面的代码可以打印出1~100。

如果要提前结束循环，可以用`break`语句：

```
n = 1
while n <= 100:
    if n > 10: # 当n = 11时，条件满足，执行break语句
        break # break语句会结束当前循环
    print(n)
    n = n + 1
print('END')
```

执行上面的代码可以看到，打印出1~10后，紧接着打印`END`，程序结束。

可见`break`的作用是提前结束循环。

### continue

在循环过程中，也可以通过`continue`语句，跳过当前的这次循环，直接开始下一次循环。

```
n = 0
while n < 10:
    n = n + 1
    print(n)
```

上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用`continue`语句跳过某些循环：

```
n = 0
while n < 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
    print(n)
```

执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。

可见`continue`的作用是提前结束本轮循环，并直接开始下一轮循环。

### 小结

循环是让计算机做重复任务的有效的方法。

`break`语句可以在循环过程中直接退出循环，而`continue`语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都*必须*配合`if`语句使用。

*要特别注意*，不要滥用`break`和`continue`语句。`break`和`continue`会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到`break`和`continue`语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉`break`和`continue`语句。

有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用`Ctrl+C`退出程序，或者强制结束Python进程。

---

# 廖雪峰 - 使用dict和set

### dict

Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：

```
names = ['Michael', 'Bob', 'Tracy']
scores = [95, 75, 85]
```

给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。

如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：

```
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```

为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。

第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。

dict就是第二种实现方式，给定一个名字，比如`'Michael'`，dict在内部就可以直接计算出`Michael`对应的存放成绩的“页码”，也就是`95`这个数字存放的内存地址，直接取出来，所以速度非常快。

你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：

```
>>> d['Adam'] = 67
>>> d['Adam']
67
```

由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

```
>>> d['Jack'] = 90
>>> d['Jack']
90
>>> d['Jack'] = 88
>>> d['Jack']
88
```

如果key不存在，dict就会报错：

```
>>> d['Thomas']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Thomas'
```

要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在：

```
>>> 'Thomas' in d
False
```

二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`，或者自己指定的value：

```
>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
```

注意：返回`None`的时候Python的交互环境不显示结果。

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除：

```
>>> d.pop('Bob')
75
>>> d
{'Michael': 95, 'Tracy': 85}
```

请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

和list比较，dict有以下几个特点：

1. 查找和插入的速度极快，不会随着key的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而list相反：

1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是**不可变对象**。

这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：

```
>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

### set

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合：

```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```

注意，传入的参数`[1, 2, 3]`是一个list，而显示的`{1, 2, 3}`只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

重复元素在set中自动被过滤：

```
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```

通过`add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果：

```
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
```

通过`remove(key)`方法可以删除元素：

```
>>> s.remove(4)
>>> s
{1, 2, 3}
```

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

```
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
```

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。

### 再议不可变对象

上面我们讲了，str是不变对象，而list是可变对象。

对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：

```
>>> a = ['c', 'b', 'a']
>>> a.sort()
>>> a
['a', 'b', 'c']
```

而对于不可变对象，比如str，对str进行操作呢：

```
>>> a = 'abc'
>>> a.replace('a', 'A')
'Abc'
>>> a
'abc'
```

虽然字符串有个`replace()`方法，也确实变出了`'Abc'`，但变量`a`最后仍是`'abc'`，应该怎么理解呢？

我们先把代码改成下面这样：

```
>>> a = 'abc'
>>> b = a.replace('a', 'A')
>>> b
'Abc'
>>> a
'abc'
```

要始终牢记的是，`a`是变量，而`'abc'`才是字符串对象！有些时候，我们经常说，对象`a`的内容是`'abc'`，但其实是指，`a`本身是一个变量，它指向的对象的内容才是`'abc'`：

```ascii
┌───┐                  ┌───────┐
│ a │─────────────────>│ 'abc' │
└───┘                  └───────┘
```

当我们调用`a.replace('a', 'A')`时，实际上调用方法`replace`是作用在字符串对象`'abc'`上的，而这个方法虽然名字叫`replace`，但却没有改变字符串`'abc'`的内容。相反，`replace`方法创建了一个新字符串`'Abc'`并返回，如果我们用变量`b`指向该新字符串，就容易理解了，变量`a`仍指向原有的字符串`'abc'`，但变量`b`却指向新字符串`'Abc'`了：

```ascii
┌───┐                  ┌───────┐
│ a │─────────────────>│ 'abc' │
└───┘                  └───────┘
┌───┐                  ┌───────┐
│ b │─────────────────>│ 'Abc' │
└───┘                  └───────┘
```

所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

### 小结

使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。

> tuple虽然是不变对象，但试试把`(1, 2, 3)`和`(1, [2, 3])`放入dict或set中，并解释结果。
>
> **(1, [2, 3])即使作为tuple也不能放入dict和set里成为key,但是可以作为value值**



# 函数

### 1. 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合** ，一共有 **4种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值

3. 有参数，无返回值
4. 有参数，有返回值

***定义函数时，是否接收参数，或者是否返回结果，是根据实际的功能需求来决定的***

1. 如果函数内部处理的数据不桷定，就可以将外界的数据以参数传递到函数内部
2. 如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值

### 2. 函数的返回值进阶

- 在程序开发中，有时候，会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理
- 返回值是函数完成工作点，最后给调用者的一个结果
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以使用变量来接收函数的返回结果

### 3. 函数的参数进阶

#### 3.1 不可变和可变的参数

- 无论传递的参数是 **可变** 还是 **不可变**

  - 只要 **针对参数** 使用 **赋值语句**，会在 函数内部 修改 **局部变量的引用**，不会影响 到 **外部变量的引用**

    【对可变参数的修改，可以通过 `extend` 方法实现】

- 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，**不会修改变量的引用**

#### 3.2 缺省参数

- 定义函数时，可以给 **某个参数** 指定一个 **默认值**，具有默认值的参数就叫做 **缺省参数**

- 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**

- 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**

```python
def print_info(name,title="", gender=True):
    pass
# 多个缺省参数时，需要指明参数名称
print_info("小美", gender=False)
```

#### 3.3 多值参数（知道）

**定义支持多值参数的函数**

- 有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用多值参数 `python` 中有两种 **多值参数**

- `python` 中有两种多值参数：

  - 参数名前增加**一个** `*` 可以接收 **元组**

  - 参数名前增加**两个** `*` 可以接收 **字典**

- 一般在给多值参数命名时，习惯使用以下两个名字
  - `*args` —— 存放元组参数，前面有一个 `*`
  - `**kwargs` —— 存放字典参数，前面有两个 `*`
- `args` 是 `arguments` 的缩写，有变量的含义
- `kw` 是 `keyword` 的缩写，`kwargs` 可以记忆键值对参数

***提示：多值参数的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码***

**元组和字典的拆包（知道）**

- 在调用带有多值参数的函数时，如果希望：
  - 将一个 **元组变量**，直接传递给 `args`
  - 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
  - 在 **元组变量前**，增加一个 `*`
  - 在 **字典变量前**，增加两个 `*`

---

# 廖雪峰 - 函数的参数

定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。

Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。

### 位置参数

我们先写一个计算x2的函数：

```
def power(x):
    return x * x
```

对于`power(x)`函数，参数`x`就是一个位置参数。

当我们调用`power`函数时，必须传入有且仅有的一个参数`x`：

```
>>> power(5)
25
>>> power(15)
225
```

现在，如果我们要计算x3怎么办？可以再定义一个`power3`函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。

你也许想到了，可以把`power(x)`修改为`power(x, n)`，用来计算xn，说干就干：

```
def power(x, n):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

对于这个修改后的`power(x, n)`函数，可以计算任意n次方：

```
>>> power(5, 2)
25
>>> power(5, 3)
125
```

修改后的`power(x, n)`函数有两个参数：`x`和`n`，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数`x`和`n`。

### 默认参数

新的`power(x, n)`函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：

```
>>> power(5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: power() missing 1 required positional argument: 'n'
```

Python的错误信息很明确：调用函数`power()`缺少了一个位置参数`n`。

这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：

```
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

这样，当我们调用`power(5)`时，相当于调用`power(5, 2)`：

```
>>> power(5)
25
>>> power(5, 2)
25
```

而对于`n > 2`的其他情况，就必须明确地传入n，比如`power(5, 3)`。

从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；

二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

使用默认参数有什么好处？最大的好处是能降低调用函数的难度。

举个例子，我们写个一年级小学生注册的函数，需要传入`name`和`gender`两个参数：

```
def enroll(name, gender):
    print('name:', name)
    print('gender:', gender)
```

这样，调用`enroll()`函数只需要传入两个参数：

```
>>> enroll('Sarah', 'F')
name: Sarah
gender: F
```

如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。

我们可以把年龄和城市设为默认参数：

```
def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
```

这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：

```
>>> enroll('Sarah', 'F')
name: Sarah
gender: F
age: 6
city: Beijing
```

只有与默认参数不符的学生才需要提供额外的信息：

```
enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')
```

可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。

有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用`enroll('Bob', 'M', 7)`，意思是，除了`name`，`gender`这两个参数外，最后1个参数应用在参数`age`上，`city`参数由于没有提供，仍然使用默认值。

也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用`enroll('Adam', 'M', city='Tianjin')`，意思是，`city`参数用传进去的值，其他默认参数继续使用默认值。

默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：

先定义一个函数，传入一个list，添加一个`END`再返回：

```
def add_end(L=[]):
    L.append('END')
    return L
```

当你正常调用时，结果似乎不错：

```
>>> add_end([1, 2, 3])
[1, 2, 3, 'END']
>>> add_end(['x', 'y', 'z'])
['x', 'y', 'z', 'END']
```

当你使用默认参数调用时，一开始结果也是对的：

```
>>> add_end()
['END']
```

但是，再次调用`add_end()`时，结果就不对了：

```
>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']
```

很多初学者很疑惑，默认参数是`[]`，但是函数似乎每次都“记住了”上次添加了`'END'`后的list。

原因解释如下：

Python函数在定义的时候，默认参数`L`的值就被计算出来了，即`[]`，因为默认参数`L`也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`了。

 定义默认参数要牢记一点：默认参数必须指向不变对象！

要修改上面的例子，我们可以用`None`这个不变对象来实现：

```
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```

现在，无论调用多少次，都不会有问题：

```
>>> add_end()
['END']
>>> add_end()
['END']
```

为什么要设计`str`、`None`这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

### 可变参数

在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。

我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。

要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：

```
def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

但是调用的时候，需要先组装出一个list或tuple：

```
>>> calc([1, 2, 3])
14
>>> calc((1, 3, 5, 7))
84
```

如果利用可变参数，调用函数的方式可以简化成这样：

```
>>> calc(1, 2, 3)
14
>>> calc(1, 3, 5, 7)
84
```

所以，我们把函数的参数改为可变参数：

```
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：

```
>>> calc(1, 2)
5
>>> calc()
0
```

如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：

```
>>> nums = [1, 2, 3]
>>> calc(nums[0], nums[1], nums[2])
14
```

这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去：

```
>>> nums = [1, 2, 3]
>>> calc(*nums)
14
```

`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。

### 关键字参数

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：

```
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```

函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw`。在调用该函数时，可以只传入必选参数：

```
>>> person('Michael', 30)
name: Michael age: 30 other: {}
```

也可以传入任意个数的关键字参数：

```
>>> person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
>>> person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```

关键字参数有什么用？它可以扩展函数的功能。比如，在`person`函数里，我们保证能接收到`name`和`age`这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

当然，上面复杂的调用可以用简化的写法：

```
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`。

### 命名关键字参数

对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过`kw`检查。

仍以`person()`函数为例，我们希望检查是否有`city`和`job`参数：

```
def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
```

但是调用者仍可以传入不受限制的关键字参数：

```
>>> person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)
```

如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收`city`和`job`作为关键字参数。这种方式定义的函数如下：

```
def person(name, age, *, city, job):
    print(name, age, city, job)
```

和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。

调用方式如下：

```
>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
```

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了：

```
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```

命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

```
>>> person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'
```

由于调用时缺少参数名`city`和`job`，Python解释器把前两个参数视为位置参数，后两个参数传给`*args`，但缺少命名关键字参数导致报错。

命名关键字参数可以有缺省值，从而简化调用：

```
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
```

由于命名关键字参数`city`具有默认值，调用时，可不传入`city`参数：

```
>>> person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
```

使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数：

```
def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
```

### 参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

比如定义一个函数，包含上述若干种参数：

```
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
```

在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。

```
>>> f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
>>> f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
>>> f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
>>> f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
>>> f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
```

最神奇的是通过一个tuple和dict，你也可以调用上述函数：

```
>>> args = (1, 2, 3, 4)
>>> kw = {'d': 99, 'x': '#'}
>>> f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
>>> args = (1, 2, 3)
>>> kw = {'d': 88, 'x': '#'}
>>> f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
```

所以，对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。

 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。

### 练习

以下函数允许计算两个数的乘积，请稍加改造，变成可接收一个或多个数并计算乘积：

```python
def mul(*numbers):
    # 判断列表是否元组
    if numbers ==():
        print("no number input")
        # 抛出异常
        raise TypeError("no number received")

    sum = 1
    for num in numbers:
        sum *= num
    return sum

print('mul(5) =', mul(5))
print('mul(5, 6) =', mul(5, 6))
print('mul(5, 6, 7) =', mul(5, 6, 7))
print('mul(5, 6, 7, 9) =', mul(5, 6, 7, 9))
if mul(5) != 5:
    print('测试失败!')
elif mul(5, 6) != 30:
    print('测试失败!')
elif mul(5, 6, 7) != 210:
    print('测试失败!')
elif mul(5, 6, 7, 9) != 1890:
    print('测试失败!')
else:
    try:
        mul()
        print('测试失败!')
    except TypeError:
        print('测试成功!')
```

### 4. 函数的递归

函数调用自身的 **编程技巧** 称为递归

#### 4.1递归函数的特点

**特点**

- 一个函数内部调用自己
  - 函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的代码是相同的，只是针对参数不同，处理的结果不同

2. 当参数满足一个条件时，函数不再执行

- 这个非常重要，通常被称为递归的出口，否则会出现死循环！

# 面向对象(O0P)基本概念

## 01. 面向对象基本概念

- 我们之前学习的编程方式就是面向过程的
- 面相过程和面相对象，是两种不同的编程方式
- 对比面向过程的特点，可以更好地了解什么是面向对象

### 1.1 过程和函数（科普）

- 过程是早期的一个编程概念
- 过程类似于函数，只能执行，但是没有返回值
- 函数不仅能执行，还可以返回结果上

### 1.2 面相过程和面相对象基本概念

#### 1）面相过程--怎么做？

1) 把完成某一个需求的所有步骤从头到尾逐步实现

2. 根据开发需求，将某些功能独立的代码封装成一个又一个函数
3. 最后完成的代码，就是顺序地调用不同的函数

**特点**

1. 注重步骤与过程，不注重职责分工
2. 如果需求复杂，代码会变得很复杂

3. 开发复杂项目，没有固定的套路，开发难度很大！

#### 2）面向对象一一谁来做？

***相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法***

1. 在完成某一个需求前，首先确定 **职责一-要做的事情（方法）**

2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的方法（多个）

3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

**特点**

1. 注重 **对象和职责**，不同的对象承担不同的职责

2. 更加适合应对复杂的需求变化，**是专门应对复杂项目开发，提供的固定套路**

3. **需要在面向过程基础上，再学习一些面向对象的语法**

<img src="assets\image-20220524172145247.png" alt="image-20220524172145247" style="zoom: 67%;" />

# 类和对象

## 01. 类和对象的概念

**类** 和 **对象** 是 **面向对象编程** 的 **两个核心概念**

### 1.1 类

- **类** 是对一群具有 **相同** **特征** 或者 **行为** 的事物的一个统称，是抽象的，**不能直接使用**

  - **特征** 被称为 **属性**

  - **行为** 被称为 **方法**

- **类** 就相当于制造飞机时的 **图纸**，是一个 **模板**，是 **负责创建对象的**

<img src="assets\image-20220524172841661.png" alt="image-20220524172841661" style="zoom:67%;" />

### 1.2 对象

对象 是 **由类创建出来的一个具体存在**，可以直接使用

- 由 **哪一个类** 创建出来的 **对象**，就拥有在 **哪一个类** 中定义的：

  - 属性

  - 方法

- **对象** 就相当于用 **图纸** **制造** 的飞机

***在程序开发中，应该先有 类 ，再有 对象***

## 02. 类和对象的关系

- **类** 是 **模板**，**对象** 是根据类这个模板创建出来的，应该 **先有类，再有对象**

- **类** 只有一个，而 **对象** 可以有很多个
  - **不同的对象** 之间 **属性** 可能会各不相同

- **类** 中定义了什么 **属性和方法**，**对象** 中就有什么属性和方法，**不可能多，也不可能少**

## 03. 类的设计

在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！

在程序开发中，要设计一个类，通常需要满足一下 **三个要素**：

1. **类名** 这类事物的名字，**满足大驼峰命名法**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为

#### 大驼峰命名法

`CapWords`

1.每一个单词的首字母大写

2.单词与单词之间没有下划线

## 3.1 类名的确定

**名词提炼法** 分析 **整个业务流程**，出现的 **名词**，通常就是找到的类

## 3.2 属性和方法的确定

- 对 **对象的特征描述**，通常可以定义成 **属性**
- **对象具有的行为**（动词），通常可以定义成 **方法**

***提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑***

# 面相对象基础语法

## 02. 定义简单的类（只包含方法）

***面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！***

### 2.1 定义只包含方法的类

- 在Python中要定义一个只包含方法的类，语法格式如下：

```python
class 类名：

	def 方法1(self,参数列表)：
		pass
	
	def 方法2(self,参数列表)：
		pass
```

- **方法** 的定义格式和之前学习过的 **函数** 几乎一样

- 区别在于第一个参数必须是 `self`，大家暂时先记住，稍后介绍 `self`

***注意：类名的命名规则要符合大驼峰命名法***

### 2.2 创建对象

- 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

  `对象变量 = 类名()`

  ```python
  class Cat:
  	"""这一个猫类"""
      def eat(self):
          print("小猫爱吃鱼")
  
      def drink(self):
          print("小猫爱喝水")
  
  
  # 创建对象
  tom = Cat()
  tom.drink()
  tom.eat()
  
  ```

### 2.3 引用概念的强调

***在面向对象开发中，引用的概念是同样适用的！***

在 `Python` 中使用类创建对象之后，`tom` 变量中仍然记录的是对象在内存中的地址

也就是 `tom` 变量引用了新建的猫对象

使用 `print` 输出对象变量，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址（十六进制表示）**

***提示：在计算机中，通常使用 十六进制 表示 内存地址***

***十进制** 和 **十六进制** 都是用来表达数字的，只是表示的方式不一样*

***十进制** 和 **十六进制** 的数字之间可以来回转换*

- `%d` 可以以 **10 进制** 输出数字
- `%x` 可以以 **16 进制** 输出数字



## 03. 方法中的 self 参数

### 3.1 案例改造 -- 给对象增加属性

- 在 `Python` 中，要 **给对象设置属性**，非常的容易，但是 **不推荐使用**
  - 因为：对象属性的封装应该封装在类的内部

- 只需要在 **类的外部的代码** 中直接通过 `.` 设置一个属性即可

***注意：这种方式虽然简单，但是不推荐使用！***

```
tom.name = "Tom"
...
lazy_cat.name = "大懒猫"
```

## 3.2 使用 self在方法内部输出每一只猫的名字

由 **哪一个对象** 调用的方法，方法内的 `self` 就是 **哪一个对象** 的引用

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**

- **调用方法时**，程序员不需要传递se1f参数

- **在方法内部**

可以通过 `self.` **访问对象的属性**

也可以通过 `self.` **调用其他的对象方法**

- 改造代码如下：

```python
class Cat:

	def eat(self):
		print("%s 爱吃鱼" % self.name)
tom = Cat()
tom.name = "Tom"
tom.eat()

lazy_cat = Cat()
lazy_cat.name = "大懒猫"
lazy_cat.eat()
```

## 04.初始化方法

### 4.1 之前代码存在的问题 -- 在类的外部给对象增加属性

- 将案例代码进行调整，**先调用方法** **再设置属性**，观察一下执行效果

```python
tom = Cat()
tom.drink()
tom.eat()
tom.name = "Tom"
print(tom)
```

- 程序执行报错如下：

```python
AttributeError: 'Cat' object has no attribute 'name'
属性错误：'Cat' 对象没有 'name' 属性
```

**提示**

- 在日常开发中，不推荐在 **类的外部** 给对象增加属性
  - 如果 **在运行时，没有找到属性，程序会报错**

- 对象应该包含有哪些属性，应该 **封装在类的内部**

### 4.2 初始化方法

- 当使用类名()

- 创建对象时，会自动执行以下操作：

  1. 为对象在内存中 **分配空间** —— 创建对象

  2. 为对象的属性 **设置初始值** —— 初始化方法( `init` )

- 这个 **初始化方法** 就是 `__init__` 方法，`__init__` 是对象的 **内置方法**

  `__init__` 方法是 **专门** 用来定义一个类 **具有哪些属性的方法**！

- 在 `Cat` 中增加 `__init__` 方法，验证该方法在创建对象时会被自动调用

```python
class Cat:
	"""这是一个猫类"""
	def __init__(self):
		print("初始化方法")
```

### 4.3 在初始化方法内部定义属性

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 **定义属性**

- 定义属性之后，再使用 `Cat` 类创建的对象，都会拥有该属性

```python
class Cat:
def __init__(self):

	print("这是一个初始化方法")

	# 定义用Cat类创建的猫对象都有一个name的属性
	self.name = "Tom"

	def eat(self):
		print("%s 爱吃鱼" % self.name)
		
# 使用类名()创建对象的时候，会自动调用初始化方法__init__
tom = Cat()
tom.eat()
```

### 4.4 改造初始化方法 -- 初始化的同时设置初始值

- 在开发中，如果希望在 **创建对象的同时**，**就设置对象的属性**，可以对 `__init__` 方法进行 **改造**

  1. 把希望设置的属性值，定义成`__init__`方法的参数


    2. 在方法内部使用 `self.属性 = 形参` 接收外部传递的参数


  3. 在创建对象时，使用 `类名（属性1，属性2..)` 调用

     ```python
     class Cat:
     
     	def __init__(self,name):
     		print("初始化方法 %s" % name)
     		self.name = name
     	...
     	
     tom = Cat("Tom")
     ...
     lazy_cat = Cat("大懒猫")
     ...
     ```

     


## 05. 内置方法和属性

| 序号 |  方法名   | 类型 | 作用                                          |
| :--: | :-------: | :--: | --------------------------------------------- |
|  01  | `__del__` | 方法 | **对象被从内存中销毁**前，会被自动调用        |
|  02  | `__str__` | 方法 | 返回 **对象的描述信息**，`print` 函数输出使用 |

### 5.1 `__del__`方法（知道）

- 在 `Python` 中

  - 当使用 `类名()` 创建对象时，为对象 **分配完空间** 后，自动调用 `__init__`方法

  - 当一个 **对象被从内存中销毁前**，会自动调用 `__del__` 方法

- 应用场景

  - `__init__` 改造初始化方法，可以让创建对象更加灵活

  - `__del__`如果希望在对象被销毁前，再做一些事情，可以考虑一下 `__del__` 方法

- 生命周期

  - 一个对象从调用 `类名()` 创建，生命周期开始

  - 一个对象的 `__del__`方法一旦被调用，生命周期结束

  - 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

### 5.2 `__str__`方法

在 `Python` 中，使用 `print` 输出 **对象变量** ，默认情况下，会输出这个变量引用的对象是由 **哪一个类创建的对象**，以及在 **内存中的地址（十六进制表示）**

- 如果在开发中，希望使用 `print` 输出 **对象变量** 时，能够打印 **自定义的内容**，就可以利用 `__str__` 这个内置方法了

***注意：`__str__`方法必须返回一个字符串***

```python
class Cat:

	def __init__(self,new_name):
		
		self.name = new_name

		print("%s 来了" % self.name)

	def __del__(self):

		print("%s 去了" % self.name)】

	def __str__(self):
		return "我是小猫：%s" % self.name

tom = Cat("Tom")
print(tom)
```

---

# 面向对象封装案例

## 01. 封装

1. **封装** 是面向对象编程的一大特点
2. 面向对象编程的 **第一步** 一一将 **属性** 和 **方法** 封装到一个抽象的 **类** 中
3. **外界** 使用 **类** 创建 **对象**，然后让对象调用方法
4. 对象方法的细节都被 **封装** 在 **类的内部**

## 02. 小明爱跑步

**需求**

1. 小明 **体重** `75.0` 公斤
2. 小明每次 **跑步** 会减肥 `0.5` 公斤
3. 小明每次 **吃东西** 体重增加 `1` 公斤

<img src="assets\image-20220525111314203.png" alt="image-20220525111314203" style="zoom: 67%;" />

## 03. 摆放家具

### 3.1 需求

1. **房子(`House`)** 有户型、总面积和家具名称列表
   - 新房子没有任何的家具

2. **家具(`HouseItem`)** 有名字和占地面积，其中

   - **席梦思 (bed)** 占地 `4` 平米

   - **衣柜 (chest)** 占地 `2` 平米

   - **餐桌 (table)** 占地 `1.5` 平米

3. 将以上三件家具 **添加** 到 **房子** 中

4. 打印房子时，要求输出：**户型**、**总面积**、**剩余面积**、**家具名称列表**

<img src="assets\image-20220525112849046.png" alt="image-20220525112849046" style="zoom: 67%;" />

### 3.2 剩余面积

1. 在创建房子对象时，定义一个 **剩余面积的属性**，**初始值和总面积相等**
2. 当调用 `add_item` 方法，向房间 **添加家具** 时，让 `剩余面积 -= 家具面积`

### 3.3 添加家具

**需求**

- 1> 判断 **家具的面积** 是否 **超过剩余面积**，**如果超过**，提示不能添加这件家具
- 2> 将 **家具的名称** 追加到 **家具名称列表** 中
- 3> 用 **房子的剩余面积 - 家具面积**

```python
class HouseItem:

    def __init__(self, name, area):
        self.name = name  # 名字
        self.area = area  # 占地面积

    def __str__(self):
        return "【%s】 占地 %.2f 平米" % (self.name, self.area)


class House:

    def __init__(self, house_type, area):
        self.house_type = house_type  # 户型
        self.area = area  # 总面积
        # 剩余面积 -> 初始值等于总面积
        self.free_area = area
        self.item_list = []  # 家具名称列表

    def __str__(self):
        return ("户型：%s \n总面积：%.2f 【剩余：%.2f】 \n家具名称列表：%s"
                % (self.house_type, self.area, self.free_area, self.item_list))

    # 添加家具
    def add_item(self, item):
        print("要添加", item)
        if item.area > self.free_area:
            print("添加失败！%s 面积太大" % item.name)

            return

        # 将家具添加至房子中
        self.item_list.append(item.name)
        # 计算剩余面积
        self.free_area -= item.area


# 1. 创建家具
bad = HouseItem("席梦思", 4)
chest = HouseItem("衣柜", 2)
tale = HouseItem("餐桌", 1.5)

# 2. 创建房子
myHouse = House("南北", 123)

# 3. 添加家具
myHouse.add_item(chest)
myHouse.add_item(bad)
myHouse.add_item(tale)

print(myHouse)

```

# 面向对象封装案例 II

## 01. 士兵突击

**需求**

1. **士兵** **许三多** 有一把 **AK47**
2. **士兵** 可以 **开火**
3. **枪** 能够 **发射** 子弹
4. **枪** 装填 **装填子弹** —— **增加子弹数量**

<img src="assets\image-20220525122532391.png" alt="image-20220525122532391" style="zoom:67%;" />

```python
# 武器
class Gun:

    def __init__(self, model, bullet_count=0):
        self.model = model  # 枪的型号
        self.bullet_count = bullet_count  # 枪的子弹数量

    def __str__(self):
        return "【%s】 子弹：%d 发" % (self.model, self.bullet_count)

    def add_bullet(self, count):
        self.bullet_count += count
        print("子弹填充完毕")

    def shoot(self):
        # 1. 判断子弹数量
        if self.bullet_count <= 0:
            print("【%s】 没有子弹了，请装填子弹！" % self.model)
            return

        # 2. 发射子弹
        self.bullet_count -= 1

        # 3. 提示信息
        print("发射子弹【剩余子弹%d】" % self.bullet_count)


# 士兵：
class Soldier:

    def __init__(self, name, gun=None):
        self.name = name  # 姓名
        self.gun = gun  # 新兵没枪

    def fire(self):
        if self.gun is None:
            print("【%s】还没枪..." % self.name)
            return
        # 警示
        print("准备射击")

        # 射击
        self.gun.shoot()

# 创建武器
ak47 = Gun("ak47", 30)

# 创建士兵
s1 = Soldier("许三多")
# 给士兵发枪
s1.gun=ak47
# 让士兵射击
s1.fire()
```

## 02. 身份运算符

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 | 描述                                      | 实例                            |
| ------ | ----------------------------------------- | ------------------------------- |
| is     | is 是判断两个标识符是不是引用同一个对象   | x is y，类似 id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a) != id(b) |

##### `is` 与 `==` 区别：

`is` 用于判断 **两个变量** 引用 **对象是否为同一个**
`==` 用于判断 **引用变量的值** 是否相等

```python
>>> a = [1,2,3]
>>> b = [1,2,3]
>>> b is a
False
>>> b == a
True
```

# 继承

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中

2. **继承** **实现代码的重用**，相同的代码不需要重复的编写

3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

## 01. 单继承

### 1.1 继承的概念、语法和特点

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

##### 1）继承的语法

```python
class 类名(父类名)
	pass
```

- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发
- **子类** 中应该根据 **职责**，封装 **子类特有的** 属性和方法

##### 2）专业术语

`Dog` 类是 `Animal` 类的 **子类**，`Animal` 类是 `Dog` 类的 **父类**，**Dog** 类从 **Animal** 类 **继承**
`Dog` 类是 `Animal` 类的 **派生类**，`Animal` 类是 `Dog` 类的 **基类**，**Dog** 类从 **Animal** 类 **派生**

##### 3）继承的传递性

`C` 类从 `B` 类继承，`B` 类又从 `A` 类 继承

那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

**子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和 **方法**

### 1.2 方法的重写

- **子类** 拥有 **父类** 的所有 **方法** 和 **属性**
- 子类 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

##### 应用场景

- 当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**

<img src="assets\image-20220525170147090.png" alt="image-20220525170147090" style="zoom: 67%;" />

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法

2. 对父类方法进行 **扩展**

##### 1）覆盖父类的方法

- 如果在开发中，**父类的方法实现** 和 **子类的方法实现**，**完全不同**
- 就可以使用 **覆盖** 的方式，在子类中 **重新编写** 父类的方法实现

***具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现***

重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法

##### 2）对父类方法进行扩展

- 如果在开发中，**子类的方法实现** 中 **包含** **父类的方法实现**
  - **父类原本封装的方法实现** 是 **子类方法的一部分**

- 就可以使用 **扩展** 的方式

1. 在子类中 **重写** 父类的方法

2. 在需要的位置使用 `super().父类` 方法来调用父类方法的执行

3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

##### 关于 `super`

- 在 `Python` 中 `super` 是一个 **特殊的类**
- `super()` 就是使用 `super` 类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

**调用父类方法的另外一种方式（知道）**

***在 `Python2.x` 时，如果需要调用父类的方法，还可以使用以下方式：***

```python
类名.方法(self)
```

- 这种方式，目前在 `Python3.x` 还支持这种方式
- 这种方法 **不推荐使用**，因为一旦 **父类发生变化**，方法调用位置的 **类名** 同样需要修改

##### 提示

- 在开发时，父类名和 `super()` 两种方式不要混用

- 如果使用 **当前子类名** 调用方法，会形成递归调用，**出现死循环**

### 1.3 父类的私有属性和私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问父类的 **私有属性** 或 **私有方法**

2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

- **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问
- **私有属性、方法** 通常用于做一些内部的事情

<img src="assets\image-20220525172848641.png" alt="image-20220525172848641" style="zoom:67%;" />

- `B` 的对象不能直接访问 `__num2` 属性
- `B` 的对象不能在 `demo` 方法内访问 `__num2` 属性
- `B` 的对象可以在 `demo` 方法内，调用父类的 `test` 方法
- 父类的 `test` 方法内部，能够访问 `num2` 属性和 `__test` 方法

```python
class A:
    def __init__(self):
        # 公有属性
        self.num1 = 100
        # 私有属性
        self.__num2 = 200

    def __test(self):
        print("私有方法 %d %d" % (self.num1, self.__num2))

    def test(self):
        # 父类可以调用自己的私有属性和方法
        print("父类的公有方法 %d"%self.__num2)
        self.__test()


class B(A):

    def demo(self):
        # 1. 在子类中，不能访问父类的私有属性
        # print("访问父类的私有属性 %d" % self.__num2)

        # 2. 在父类中，不能调用父类的私有方法
        # self.__test()

        # 3. 访问父类的公有属性
        print("子类方法 %d" % self.num1)

        # 4. 调用父类的公有方法
        self.test()
        pass


# 创建一个子类对象
b = B()
print(b.demo())

# 在外界不能直接访问对象的私有属性或私有方法
# print(b.__num2)
# b.__test()

# 调用父类的公有属性
print(b.num1)
# 调用父类的公有方法
b.demo()
```

## 02. 多继承

##### 概念

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

<img src="assets\image-20220525192757342.png" alt="image-20220525192757342" style="zoom:50%;" />

##### 语法

```python
class 子类名(父类名1,父类名2...)
	pass
```

### 2.1 多继承的使用注意事项

**问题的提出**

- 如果 **不同的父类** 中存在 **同名的方法**，子类对象在调用方法时，会调用 **哪一个父类** 中的方法呢？

***提示：开发时，应该尽量避免这种容易产生混淆的情况！——如果父类之间 存在同名的属性 或者 方法，应该 尽量避免 使用 多继承***

<img src="assets\image-20220525193312328.png" alt="image-20220525193312328" style="zoom:50%;" />

##### Python中的MRO--方法搜索顺序（知道）

`Python` 中针对类提供了一个内置属性 `__mro__` 可以查看 **方法搜索顺序**
MRO 是 `method resolution order` ，主要用于 **在多继承时判断** 方法、**属性的调用** **路径**

```python
print(C.__mro___)
```

**输出结果**

```python
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照 `__mro__`的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

# 多态

##### 面向对象三大特性

1. **封装** 根据 **职责** 将 **属性** 和 **方法** 封装到一个抽象的 **类** 中
   - 定义类的准则

1. **继承** **实现代码的重用**，相同的代码不需要重复的编写

   - 设计类的技巧

   - 子类针对自己特有的需求，编写特定的代码

1. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果

- **多态** 可以 **增加代码的灵活度**

- 以 **继承** 和 **重写父类方法** 为前提

- 是调用方法的技巧，**不会影响到类的内部设计**

<img src="assets\image-20220526203059130.png" alt="image-20220526203059130" style="zoom: 67%;" />

​		

```python
class Dog(object):

    def __init__(self, name):
        self.name = name;

    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)


class XiaoTianQuan(Dog):

    # 重写父类的 game 方法
    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):
        print(self.name, "和", dog.name, "快乐玩耍...")

        # 让狗玩耍
        dog.game()


# 1. 创建Dog对象
wangCai = XiaoTianQuan("哮天旺财")
# 2. 创建Person对象
xiaoMing = Person("小明")
# 3.调用 game_with_dog 方法
xiaoMing.game_with_dog(wangCai)
```



# 私有属性和私有方法

## 01. 应用场景及定义方式

**应用场景**

- 在实际开发中，**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**
- **私有属性** 就是 **对象** 不希望公开的 **属性**
- **私有方法** 就是 **对象** 不希望公开的 **方法**

**定义方式**

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

<img src="assets\image-20220525162221937.png" alt="image-20220525162221937" style="zoom: 80%;" />

```python
class Women:

    def __init__(self, name):
        self.name = name;
        self.__age = 18

    def __secret(self):
        # 在对象的方法内部，是可以访问对象的私有属性的
        print("%s 的年龄是 %d" % (self.name, self.__age))


XiaoFang = Women("小芳")

# 私有属性在外界不能够被直接访问
# print(XiaoFang.__age)
# 私有方法同样不允许在外界直接访问
XiaoFang.__secret()
```

## 02. 伪私有属性和私有方法（科普）

***提示：在日常开发中，不要使用这种方式，访问对象的私有属性或私有方法***

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理使得外界无法访问到

- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

```python
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```

## 廖雪峰 —— 访问限制

在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的`name`、`score`属性：

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.score
59
>>> bart.score = 99
>>> bart.score
99
```

如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：

```python
class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
```

改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问`实例变量.__name`和`实例变量.__score`了：

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
```

这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。

但是如果外部代码要获取name和score怎么办？可以给Student类增加`get_name`和`get_score`这样的方法：

```python
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
```

如果又要允许外部代码修改score怎么办？可以再给Student类增加`set_score`方法：

```python
class Student(object):
    ...

    def set_score(self, score):
        self.__score = score
```

你也许会问，原先那种直接通过`bart.score = 99`也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：

```python
class Student(object):
    ...

    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
```

需要注意的是，在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用`__name__`、`__score__`这样的变量名。

有些时候，你会看到以一个下划线开头的实例变量名，比如`_name`，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量：

```python
>>> bart._Student__name
'Bart Simpson'
```

但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把`__name`改成不同的变量名。

总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。

最后注意下面的这种*错误写法*：

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.get_name()
'Bart Simpson'
>>> bart.__name = 'New Name' # 设置__name变量！
>>> bart.__name
'New Name'
```

表面上看，外部代码“成功”地设置了`__name`变量，但实际上这个`__name`变量和class内部的`__name`变量*不是*一个变量！内部的`__name`变量已经被Python解释器自动改成了`_Student__name`，而外部代码给`bart`新增了一个`__name`变量。不信试试：

```python
>>> bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
```

# 类属性和类方法

## 01. 类的结构

### 1.1术语 -- 实例

1. 使用面相对象开发，**第 1 步** 是设计 **类**

2. 使用 `类名()` 创建对象，`创建对象` 的动作有两步：

   1）在内存中为对象 `分配空间`

   2）调用初始化方法 `__init__` 为 **对象初始化**

3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 —— **实例**

<img src="assets\image-20220526204504368.png" alt="image-20220526204504368" style="zoom: 67%;" />

因此，通常也会把：

1. 创建出来的 **对象** 叫做 **类的实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. 对象的 **属性** 叫做 **实例属性**
4. 对象调用的 **方法** 叫做 **实例方法**

##### 结论

- **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法**，在内存中只有一份，在调用方法时，**需要把对象的引用** 传递到方法内部

## 1.2 类是一个特殊的对象

> `Python` 中 **一切皆对象**：
>
> `class AAA:` 定义的类属于 **类对象**
>
> `obj1 = AAA()`  属于 **实例对象**

在程序运行时，**类** 同样 **会被加载到内存**

在 `Python` 中，**类** 是一个特殊的对象 —— **类对象**

在程序运行时，**类对象** 在内存中 **只有一份**，使用 **一个类** 可以创建出 **很多个对象实例**

除了封装 **实例** 的属性和 **方法** 外，**类对象** 还可以拥有自己的 **属性** 和 **方法**

1. **类属性**
2. **类方法**

通过 `类名.` 的方式可以 `访问类的属性` 或者 `调用类的方法`

<img src="assets\image-20220526210820078.png" alt="image-20220526210820078" style="zoom:67%;" />

## 02. 类属性和实例属性

### 2.1 概念和使用

- **类属性** 就是给 **类对象** 中定义的 **属性**
- 通常用来记录 **与这个类相关** 的特征
- **类属性** 不会用于记录 **具体对象** 的特征

**示例需求**

- 定义一个 工具类
- 每件工具都有自己的 `name`
- **需求** —— 知道使用这个类，创建了多少个工具对象？

<img src="assets\image-20220526211323376.png" alt="image-20220526211323376" style="zoom:80%;" />

```python
class Tool(object):
    # 使用赋值语句定义属性，记录所有工具对象的数量
    count = 0

    def __init__(self, name):
        self.name = name

        # 让类属性的值+1
        Tool.count += 1


# 1. 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("螺丝刀")
tool3 = Tool("榔头")

# 2. 输出工具对象的总数
print(Tool.count)
```

### 2.2 属性的获取机制（科普）

- 在 `Python` 中 **属性的获取** 存在一个 **向上查找机制**

![image-20220526213927107](assets\image-20220526213927107.png)

- 因此，要访问类属性有两种方式：

1. 类名.类属性

   ```python
   # 推荐的方法
   Tool.count
   ```

2. 对象类属性（不推荐）

注意：

- 如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性** ，而不会影响到 **类属性的值**

## 03. 类方法和静态方法

### 3.1 类方浅

- **类属性** 就是针对 **类对象** 定义的属性

  - 使用赋值语句在 `class` 关键字下方可以定义 **类属性**

  - **类属性** 用于记录 **与这个类相关** 的特征

- **类方法** 就是针对 **类对象** 定义的方法
  - 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法如下**

```python
@classmethod
def 类方法名(cls):
	pass
```

- 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**

- 类方法的 **第一个参数** 应该是 `cls`

  - 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**

  - 这个参数和 **实例方法** 的第一个参数是 `self` 类似

  - **提示** 使用其他名称也可以，不过习惯使用 `cls`

- 通过 `类名.` 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数

- **在方法内部**

  - 可以通过 `cls.` **访问类的属性**

  - 也可以通过 `cls.` **调用其他的类方法**

    ```python
    class Tool(object):
        # 使用赋值语句定义属性，记录所有工具对象的数量
        count = 0
    
        @classmethod
        def show_tool_count(cls):
            print("工具对象的数量", cls.count)
    
        def __init__(self, name):
            self.name = name
    
            # 让类属性的值+1
            Tool.count += 1
    
    
    # 1. 创建工具对象
    tool1 = Tool("斧头")
    tool2 = Tool("螺丝刀")
    tool3 = Tool("榔头")
    
    # 2. 输出工具对象的总数
    Tool.show_tool_count()
    ```

    

> 在类方法内部，可以直接使用 `cls` 访问 **类属性** 或者 **调用类方法**

### 3.2 静态方法

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：

  - 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**

  - 也 **不需要** 访问 **类属性** 或者调用 **类方法**

- 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```python
@staticmethod
def 静态方法名()：
	pass
```

- **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，`告诉解释器这是一个静态方法`

- 通过 `类名.` 调用 **静态方法**

  ```python
  class Dog(object):
  
      # 不需要访问 Dog 类属性、对象属性。可以把他定义成静态方法
      @staticmethod
      def run():
          print("小狗要跑...")
  
  # 通过类名.调用静态方法
  Dog.run()
  ```

### 3.3 方法综合案例

##### 需求

1. 设计一个 `Game` 类

2. 属性：
   定义一个 **类属性** `top_score` 记录游戏的 **历史最高分**

   定义一个 **实例属性** `player_name` 记录 **当前游戏的玩家姓名**

3. 方法：
   **静态方法** `show_help` 显示游戏帮助信息
   **类方法** `show_top_score` 显示历史最高分
   **实例方法** `start_game` 开始当前玩家的游戏

4. 主程序步骤
   1）查看帮助信息
   2）查看历史最高分
   3）创建游戏对象，开始游戏

<img src="assets\image-20220527122019715.png" alt="image-20220527122019715" style="zoom:80%;" />

```python
class Game(object):
    # 历史最高分
    top_score = 0

    def __init__(self, player_name):
        self.player_names = player_name

    # 类方法，显示历史最高分
    @classmethod
    def show_top_score(cls):
        print("历史最高分：", cls.top_score)

    # 静态方法，显示游戏帮助信息
    @staticmethod
    def show_help():
        print("Help information：good good study day day up")

    # 实例方法，开始当前玩家的游戏
    def start_game(self):
        print(self.player_names, "开始游戏")


# 静态方法和类方法都是通过 类名. 的方式访问
# 1. 查看帮助信息
Game.show_help()
# 2. 查看历史最高分
Game.show_top_score()


# 3. 开始游戏
game = Game("nancy")
game.start_game()
```

**案例小结**

1. **实例方法** —— 方法内部需要访问 **实例属性**
   - **实例方法** 内部可以使用 `类名.` 访问类属性
2. **类方法** —— 方法内部 **只** 需要访问 **类属性**
3. **静态方法** —— 方法内部，不需要访问 **实例属性** 和 **类属性**

**提问**

​	如果方法内部即需要访问 **实例属性**，又需要访问 **类属性**，应该定义成什么方法？

**答案**

- 应该定义 **实例方法**
- 因为，**类只有一个**，在 **实例方法** 内部可以使用 `类名.` 访问类属性

# 单例

## 01. 单例设计模式

- 设计模式

  - **设计模式** 是 **前人工作的总结和提炼**，通常，被人们广泛流传的设计模式都是针对 **某一特定问题** 的成熟的解决方案

  - 使用 **设计模式** 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性

- 单例设计模式

  - **目的** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**

  - 每一次执行 `类名()` 返回的对象，**内存地址是相同的**

##### 单例设计模式的应用场景

- **音乐播放** 对象 【同一时间只能播放一首歌曲 —— 唯一】
- **回收站** 对象 【只有一个回收站 —— 唯一】
- **打印机** 对象  【打印机只能一份一份来工作 —— 唯一】
- ... ...

###  02. `__new__` 方法

- 使用 `类名()` 创建对象时，`Python` 的解释器 **首先** 会 调用 `__new__` 方法为对象 **分配空间**

- `__new__` 是一个由 `object` 基类提供的 **内置的静态方法**，主要作用有两个：

  - 1）在内存中为对象 **分配空间**

  - 2）**返回** 对象的引用

- `Python` 的解释器获得对象的 **引用** 后，将引用作为 **第一个参数**，传递给 `__init__` 方法

> *重写 `__new__` 方法的代码非常固定！*

- 重写 `__new__` 方法 **一定要** `return super().__new__(cls)`
- 否则 `Python` 的解释器 `得不到` 分配了空间的 **对象引用**，**就不会调用对象的初始化方法**
- 注意：`__new__` 是一个静态方法，在调用时需要 **主动传递** `cls` 参数

<img src="assets\image-20220527125506639.png" alt="image-20220527125506639" style="zoom: 67%;" />

## 03. Python中的单例

- **单例** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**

  1. 定义一个 **类属性**，初始值是 `None` ，用于记录 **单例对象的引用**
  2. 重写 `__new__` 方法
  3. 如果 **类属性** `is None`，调用父类方法分配空间，并在类属性中记录结果
  4. 返回 **类属性** 中记录的 **对象引用**

  ```python
  class MusicPlayer(object):
      # 记录第一个被创建对象的引用
      instance = None
  
      def __new__(cls, *args, **kwargs):
          # 1. 判断类属性是否是空对象
          if cls.instance is None:
              # 2. 调用父类的方法，为第一个对象分配空间
              cls.instance = super().__new__(cls)
  
          # 3. 返回类属性保存的对象引用
          return cls.instance
  
      def __init__(self):
          print("初始化会被调用两次")
  
  player1 = MusicPlayer()
  player2 = MusicPlayer()
  
  print(player1)
  print(player2)
  ```

  

##### 只执行一次初始化工作

- 在每次使用 `类名()` 创建对象时，`Python` 的解释器都会自动调用两个方法：

  - `__new__` 分配空间

  - `__init__` 对象初始化

- 在上一小节对 `__new__` 方法改造之后，每次都会得到 `第一次被创建对象的引用`
- 但是：**初始化方法还会被再次调用**

##### 需求

- 让 **初始化动作** 只被执行一次

##### 解决办法

1. 定义一个类属性 `init_flag` 标记是否 **执行过初始化动作**，初始值为 `False`
2. 在 `__init__` 方法中，判断 `init_flag` ，如果为 `False` 就执行初始化动作
3. 然后将 `init_flag` 设置为 `True`
4. 这样，再次自动调用 `__init__` 方法时，**初始化动作就不会被再次执行了**

# 异常

## 01. 异常的概念

- 程序在运行时，如果 `Python 解释器` **遇到** 到一个错误，**会停止程序的执行**，**并且提示一些错误信息**，这就是 **异常**
- **程序停止执行并且提示错误信息这个动作**，我们通常称之为：**抛出(raise)异常**

<img src="assets\image-20220527144458983.png" alt="image-20220527144458983" style="zoom:80%;" />

> 程序开发时，很难将 **所有的特殊情况** 都处理的面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的 **稳定性和健壮性**

## 02. 捕获异常

### 2.1 简单的捕获异常语法

- 在程序开发中，如果 **对某些代码的执行不能确定是否正确**，可以增加 `try(尝试)` 来 **捕获异常**

- 捕获异常最简单的语法格式：

```python
try:
	尝试执行的代码
except:
	出现错误的处理
```

- `try` **尝试**，下方编写要尝试代码，不确定是否能够正常执行的代码
- `except` **如果不是**，下方编写尝试失败的代码

**简单异常捕获演练 —— 要求用户输入整数**

```python
try:
    # 不能确定正确执行的代码
    # 提示用户输入一个数字
    num = int(input("请输入一个整数："))
except:
    # 错误的处理代码
    print("请输入正确的数字")
```

### 2.2 错误类型捕获

- 在程序执行时，可能会遇到 **不同类型的异常**，并且需要 **针对不同类型的异常**，**做出不同的响应**，这个时候，就需要捕获错误类型了

- 语法如下：

当 `Python` 解释器 **抛出异常** 时，**最后一行错误信息的第一个单词**，**就是错误类型异常类型捕获演练 —— 要求用户输入整数**

### 捕获已知异常

##### 需求

1. 提示用户输入一个整数

2. 使用 `8` 除以用户输入的整数并且输出

   ```python
   try:
       # 提示用户输入一个数字
       num = int(input("请输入一个整数："))
   
       # 使用 8 除以用户输入的整数并且输出
       result = 8 / num
   
       print(result)
   
   except ZeroDivisionError:
       print("被除数不能为 0 ")
   except ValueError:
       print("请输入正确的整数")
   ```

   

### 捕获未知错误

- 在开发时，**要预判到所有可能出现的错误**，还是有一定难度的

- 如果希望程序 **无论出现任何错误**，都不会因为 `Python` 解释器 **抛出异常而被终止**，可以再增加一个`except`

  ```python
  try:
      # 提示用户输入一个数字
      num = int(input("请输入一个整数："))
  
      # 使用 8 除以用户输入的整数并且输出
      result = 8 / num
  
      print(result)
  
  except Exception as result:
      print("未知错误！ %s" % result)
  ```

  

### 2.3 异常捕获完整语法

- 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：

> *提示*：
>
> 有关完整语法的应用场景，在后续学习中，**结合实际的案例** 会更好理解
>
> 现在先对这个语法结构有个印象即可

- `else` 只有在没有异常时才会执行的代码
- `finally` 无论是否有异常，都会执行的代码
- 之前一个演练的 **完整捕获异常** 的代码如下：

```python
try:
    # 提示用户输入一个数字
    num = int(input("请输入一个整数："))

    # 使用 8 除以用户输入的整数并且输出
    result = 8 / num

    print(result)

except ZeroDivisionError:
    print("被除数不能为 0 ")
except ValueError:
    print("请输入正确的整数")
except Exception as result:
    print("未知错误！ %s" % result)
else:
    print("执行过程中无异常发生")
finally:
    print("无论是否出现异常都会执行")、
```

## 03. 异常的传递

- **异常的传递** —— 当 **函数 / 方法** 执行 **出现异常**，会 **将异第传递** 给 函数 / 方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理**，程序才会被终止

**提示**

- 在开发中，可以在主函数中增加 **异常捕获**
- 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
- 这样就不需要在代码中，增加大量的 **异常捕获**，能够保证代码的整洁

##### 需求

1. 定义函数 `demo1()` **提示用户输入一个整数并且返回**

2. 定义函数 `demo2()` 调用 `demo1()`

3. 在主程序中调用 `demo2()`

   ```python
   def demo1():
       return int(input("请输入整数："))
   
   def demo2():
       return demo1()
   
   # 利用异常的传递性，在主程序捕获异常
   
   try:
       print(demo2())
   except Exception as result:
       print("错误位置", result)
   ```

   

## 04. 抛出 raise 异常

### 4.1 应用场景

- 在开发中，除了 **代码执行出错** `Python` 解释器会 **抛出** 异常之外
- 还可以根据 **应用程序** **特有的业务需求** **主动抛出异常**

##### 示例

- 提示用户 **输入密码**，如果 **长度少于**8，抛出 **异常**

<img src="assets\image-20220527172521940.png" alt="image-20220527172521940" style="zoom:80%;" />

##### 注意

- 当前函数 **只负责** 提示用户输入密码，如果 **密码长度不正确，需要其他的函数进行额外处理**
- 因此可以 **抛出异常**，由其他需要处理的函数 **捕获异常**

## 4.2 抛出异常

- `Python` 中提供了一个 `Exception` **异常类**
- 在开发时，如果满足 **特定业务需求时**，希望 **抛出异常**，可以：

1. **创建一个** `Exception` 的 **对象**
2. 使用 `raise` **关键字** 抛出 **异常对象**

##### 需求

- 定义 `input_password` 函数，提示用户输入密码

- 如果用户输入长度 `< 8` ，抛出异常

- 如果用户输入长度 `>= 8`，返回输入的密码

  ```python
  def input_password():
      # 1. 提示用户输入密码
      pwd = input("请输入密码：")
      # 2. 判断密码长度 >= 8 ，返回用户输入密码
      if len(pwd) >= 8:
          return pwd
  
      # 3. 如果 < 8 主动抛出异常
  
      # 1> 创建异常对象
      ex = Exception("密码长度不够")
  
      # 2> 主动抛出异常
      raise ex
  
  try:
      print(input_password())
  except Exception as result:
      print(result)
  ```

# 模块

## 01. 模块

### 1.1 模块的概念

> 模块是 `Python` 程序架构的一个核心概念

- 每一个以扩展名 `.py` 结尾的 `Python` 源代码文件都是一个模块
- **模块名** 同样也是一个 **标识符**，需要 **符合标识符的命名规则**
- 在模块中定义的 **全局变量**、**函数**、**类** 都是提供给外界直接使用的 **工具**
- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要先 **导入** 这个模块

### 1.2 模块的两种导入方式

##### 1）import 导入

```python
import 模块名1，模块名2
```

> 提示：在导入模块时，每个 **导入应该独占一行**

```python
import 模块名1
import 模块名2
```

- **导入之后**
  - 通过 `模块名.` 使用 **模块提供的工具 —— 全局变量、函数、类**

**代码如下：**

- 模块 1

```python
# 全局变量
title = "模块1"

# 函数
def say_hello():
    print("我是",title)

# 类
class Dog(object):
    pass
```

- 模块 2

```python
# 全局变量
title = "模块2"

# 函数
def say_hello():
    print("我是", title)

# 类
class Cat(object):
    pass
```

- 主文件

```python
import hm_01_测试模块1
import hm_02_测试模块2

hm_01_测试模块1.say_hello()
hm_02_测试模块2.say_hello()

dog = hm_01_测试模块1.Dog()
print(dog)

cat = hm_02_测试模块2.Cat()
print(cat)
```

**使用 `as` 指定模块的别名**

> **如果模块的名字太长**，可以使用 `as` 指定模块的名称，以方便在代码中的使用

```python
import 模块名1 as 模块别名
```

> 注意：**模块别名** 应该符合 **大驼峰命名法**

##### 2）from...import 导入

- 如果希望 **从某一个模块** 中，导入 **部分** 工具，就可以使用 `from...import` 的方式
- `import 模块名` 是 **一次性** 把模块中 **所有工具全部导入**，并且通过 **模块名 / 别名** 访问

```python
# 从模块导入某一个工具
from 模块名1 import 工具名
```

- 导入之后

  - **不需要** 通过 `模块名.`

  - 可以直接使用 **模块提供的工具 —— 全局变量、函数、类**

    ```python
    from hm_01_测试模块1 import Dog
    from hm_02_测试模块2 import say_hello
    
    say_hello()
    
    WangCai = Dog
    print(WangCai)
    ```



> **注意：如果 **两个模块**，存在 **同名的函数**，那么 **后导入模块的函数**，会 **覆盖掉先导入的函数**

- 开发时 `import` 代码应该统一写在 **代码的顶部**，更容易及时发现冲突

- 一旦发现冲突，可以使用 `as` 关键字给其中一个工具 **起一个别名**

  ```python
  # 从模块导入所有工
  from 模块名1 import *
  ```

>注意：这种方式 **不推荐使用**，因为函数重名并没有任何的提示，**出现问题不好排查**

```python
from hm_01_测试模块1 import *
from hm_02_测试模块2 import *

# 出现冲突不好排查
print(title)
say_hello()
```

### 1.3 模块的搜索顺序 [扩展]

`Python` 的解释器在 **导入模块** 时，会：

1. 搜索当前目录指定模块名的文件，如果有就直接导入
2. 如果没有，再搜索系统目录

> *在开发时，给文件起名，**不要和系统的模块文件 重名***

`Python` 中每一个模块都有一个内置属性 `__file__` 可以 **查看模块** 的 **完整路径**

**示例**

```python
import random

# 生成一个0 ~ 10的数字
rand = random.randint(0,10)
print(rand)
```

> *注意：如果当前目录下，存在一个 `random.py`，的文件，程序就无法正常执行了！*

- 这个时候，`Python` 的解释器会 **加载当前目录** 下的 `random.py` 而不会加载系统的 `random` 模块

### 1.4 原则 —— 每一个文件都应该是可以被导入的

- **一个独立的** `Python` **文件** 就是一个 **模块**
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍！

##### 实际开发场景

- 在实际开发中，每一个模块都是独立开发的，大多都有专人负责
- **开发人员** 通常会在 **模块下方** **增加一些测试代码**
  - 仅在模块内使用，而被导入到其他文件中不需要执行

##### `__name__` 属性

> *`__name__` 属性可以做到，测试模块的代码 **只在测试情况下被运行**，而 **在被导入时不会被执行**！*

- `__name__` 是 `Python` 的一个内置属性，记录着一个 **字符串**

- 如果 **是被其他文件导入的**，`__name__` 就是 **模块名**

- 如果是 **当前执行的程序** `__name__` 是 `__main__`

  ```python
  # 根据 __name__ 判断是否执行下方代码
  if __name__ == "__main__":
      print(__name__)
  
      # 文件被导入时，能够直接执行的代码不需要执行
      print("小明开发的模块")
      say_hello()
  ```




## 02. 包 (Package)

##### 概念

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 目录下有一个 **特殊的文件** `__init__·py`
- 包名的 **命名方式** 和变量名一致，**小写字母** + `_`

##### 好处

使用 `import 包名` 可以一次性导入 **包** 中 **所有的模块**

### 案例演练

1. 新建一个 `hm_message` 的包
2. 在目录下，新建两个文件 `send_message` 和 `receive_message`
3. 在 `send_message` 文件中定义一个send函数
4. 在 `receive_message` 文件中定义一个receive函数
5. 在外部直接导入`hm_message` 的包 

### `__init__.py`

要在外界使用 `包` 中的模块需要在 `__init__py` 中指定 **对外界提供的模块列表**

- `__init__.py`

  ```python
  # 从当前目录导入模块列表
  from . import send_message
  from . import receive_message
  ```

- `send_message`

  ```python
  def send(text):
      print("正在发送",text,"...")
  ```

- `receive_message`

  ```python
  def receive():
      return "这是来自 10010 的短信"
  ```

- 主函数

  ```python
  import hm_message
  
  hm_message.send_message.send("hello")
  
  print(hm_message.receive_message.receive())
  ```

## 03. 发布模块 (知道)

- 如果希望自己开发的模块，**分享** 给其他人，可以按照以下步骤操作

### 3.1 制作发布压缩包步骤

1. 创建 setup.py

   - `setup.py` 的文件

   ```python
   from distutils.core import setup
   
   setup(name="hm_message",  # 包名
         version="1.0",  # 版本
         description="itheima's发送和接收消息模块",  # 描述信息
         Long_description="完整的发送和接收消息模块",  # 完整描述信息
         author="itheima",  # 作者
         author_email="itheima@itheima.com",  # 作者邮箱
         url="www.itheima.com",  # 主页
         py_modules=["hm_message.send_message",
                     "hm_message.receive_message"])
   ```

2. 构建模块

   ```shell
   ❯ python3 setup.py build      
   ```

   

3. 生成发布压缩包

   ```shell
   ❯ python3 setup.py sdist       
   ```

   

### 3.2 安装模块

- 安装模块

  ```shell
  ❯ python3 setup.py install  
  ```

  

### 3.3 卸载模块

- 卸载模块

  ```shell
  ❯ rm -r hm_message*
  ```


### 3.4 pip 安装第三方模块

- **第三方模块** 通常是指由 **知名的第三方团队** 开发的并且被 **程序员广泛使用** 的 `Python` 包 / 模块
  - 例如 `pygame` 就是一套非常成熟的 **游戏开发模块**

- `pip` 是一个现代的，通用的 `Python` 包管理工具
- 提供了对 `Python` 包的查找、下载、安装、卸载等功能

安装和卸载命令如下：

```shell
# 将模块安装到Python2.X环境
❯ pip install pygame           
❯ pip uninstall pygame          

# 将模块安装到Python3.X环境
❯ pip3 install pygame      
❯ pip3 uninstall pygame     
```

# 文件

## 01. 文件的概念

### 1.1 文件的概念和作用

- 计算机的 **文件**，就是存储在某种 **长期储存设备** 上的一段 **数据**
- 长期存储设备包括：硬盘、U盘、移动硬盘、光盘

##### 文件的作用

将数据长期保存下来，在需要的时候使用

<img src="assets\image-20220528183303494.png" alt="image-20220528183303494" style="zoom:67%;" />

### 1.2 文件的存储方式

- 在计算机中，文件是以 **二进制** 的方式保存在磁盘上的

- 保存的内容不是给人直接阅读的，而是 **提供给其他软件使用的**

- 例如：图片文件、音频文件、视频文件等等
- 二进制文件不能使用 **文本编辑软件** 查看

## 02. 文件的基本操作

### 2.1 操作文件的套路

在计算机中要操作文件的套路非常固定，一共包含三个步骤：

1. 打开文件

2. 读、写文件

   - **读** 将文件内容读入内存

   - **写** 将内存内容写入文件

3. 关闭文件

### 2.2 操作文件的函数/方法

- 在 `Python` 中要操作文件需要记住 1 个函数和 3 个方法

| 序号 |       |                                |
| ---- | ----- | ------------------------------ |
| 01   | open  | 打开文件，并且返回文件操作对象 |
| 02   | read  | 将文件内容读取到内存           |
| 03   | write | 将指定内容写入文件             |
| 04   | close | 关闭文件                       |

- `open` 函数负责打开文件，并且返回文件 对象
- `read` / `write` / `close` 三个方法都需要通过 **文件对象** 来调用

### 2.3 read 方法 —— 读取文件

- `open` 函数的第一个参数是要打开的胶件名（文件名区分大小写）

  - 如果文件 **存在**，返回 **文件操作对象**

  - 如果文件 **不存在**，会 **抛出异常**

- `read` 方法可以一次性 **读入** 并 **返回** 文件的 **所有内容**
- `close` 方法负责 **关闭文件**
  - 如果 **忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问**

> **注意**：方法执行后，会把文件指针移动到 **文件的末尾**

```python
# 1. 打开文件
file = open("README.md")

# 2.读取
text=file.read()

# 3. 关闭
file.close()
```

> 提示：在开发中，通常会先编写 **打开** 和 **关闭** 的代码，再编写中间针对文件的 **读 / 写** 操作！

##### 文件指针（知道）

- 文件指针标记 **从哪个位置开始读取数据**
- **第一次打开文件时**，通常文件指针会指向 **文件的开始位置**
- 当执行了 `read` 方法后，**文件指针会移动到读取内容的末尾**
  - 默认情况下会 **移动到文件末尾**

### 2.4 打开文件的方式

- `open` 函数默认以 **只读方式** 打开文件，并且返回文件对象

**语法如下：**

```python
f = open("文件名","访问方式")
```

<img src="assets\image-20220528185910043.png" alt="image-20220528185910043" style="zoom:80%;" />

> 提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以只读、只写的方式来操作文件

```python
# 1. 打开文件
file = open("README.md","w")

# 2.写入文件
text=file.write("使用 Python 添加")

# 3. 关闭
file.close()
```

### 2.5按行读取文件内容

- `read` 方法默认会把文件的 **所有内容一次性读取到内存**
- 如果文件太大，对内存的占用会非常严重

##### readline 方法

- `readline` 方法可以一次读取一行内容
- 方法执行后，会把 **文件指针** 移动到下一行，准备再次读取

##### 读取大文件的正确姿势

```python
file = open("README.md")

while True:
    text = file.readline()

    # 判断是否读取到内容
    if not text:
        break

    # 每读取一行的末尾已经有了一个 '\n'
    print(text,end="")

file.close()
```

### 2.6 文件读写案例 —— 复制文件

<img src="assets\image-20220528191331275.png" alt="image-20220528191331275" style="zoom:50%;" />

##### 小文件复制

- 打开一个已有文件，读取完整内容，并写入到另外一个文件

  ```python
  # 1. 打开
  file_read = open("README.md","r")
  file_write = open("README[副本].md","w")
  
  # 2. 读写
  file_write.write(file_read.read())
  
  # 3. 关闭
  file_read.close()
  file_write.close()
  ```

##### 大文件复制

- 打开一个已有文件，逐行读取函容，并顺序写入到另外一个文件

  ```python
  # 1. 打开
  file_read = open("README.md","r")
  file_write = open("README[副本].md","w")
  
  # 2. 读写
  while True:
      # 读取一行内容
      text = file_read.readline()
      # 判断是否读取到内容
      if not text:
          break
  
      file_write.write()
  
  # 3. 关闭
  file_read.close()
  file_write.close()
  ```

## 03. 文件 / 目录的常用管理操作

- 在 **终端 / 文件浏览器**、中可以执行常规的 **文件 / 目录** 管理操作，例如：
  - 创建、重命名、删除、改变路径、查看目录内容、

- 在 `Python` 中，如果希望通过程序实现上述功能，需要导入 `os` 模块

##### 文件操作

<img src="assets\image-20220528192742683.png" alt="image-20220528192742683" style="zoom:80%;" />

##### 目录操作

<img src="assets\image-20220528192756154.png" alt="image-20220528192756154" style="zoom:80%;" />

> *提示：文件或者目录操作都支持 **相对路径** 和 **绝对路径***

## 04.文本文作的编码格式（科普）

- 文本文件存储的内容是基于 **字符编码** 的文件，常见的编码有 `ASCII` 编码、`UNICODE` 编码等

> `Python2.x` 默认使用 `ASCII` 编码
>
> `Python3.x` 默认使用 `UTF-8` 编码

### 4.1 ASCII 编码和 UNICODE 编码

##### ASCII编码

- 计算机中只有 `256` 个 `ASCII` 字符
- 一个 `ASCII` 在内存中占用 **1个字节** 的空间
  - 8 `个` `0 / 1` 的排列组合方式一共有 `256` 种，也就是 `2 ** 8`

![image-20220528193140387](assets\image-20220528193140387.png)

##### UTF-8 编码格式

- 计算机中使用 **1 ~ 6 个字节** 来表示一个 `UTF-8` 字符，涵盖了 **地球上几乎所有地区的文字**
- 大多数汉字会使用 3**个字节** 表示
- UTF-`8` 是 `UNICODE` 编码的一种编码格式

### 4.2 Ptyhon2.x 中如何使用中文

> `Python2.x` 默认使用 ASCII 编码格式
> `Python3.x` 默认使用 UTF-8 编码格式

- 在 Python2.x 文件的 **第一行** 增加以下代码，解释器会以 `utf-8` 编码来处理 `Python` 文件

```python
# *-* coding:utf-8 *-*
```

> *这方式是官方推荐使用的！*

- 也可以使用

```python
# coding = utf8
```

##### unicode 字符串

- 在 `Python2.x` 中，即使指定了文件使用 `UTF-8` 的编码格式，但是在遍历字符串时，仍然会 **以字节为单位遍历** 字符串
- 要能够 **正确的遍历字符串**，在定义字符串时，需要 **在字符串的引号前**，增加一个小写字母 `u`，告诉解释器这是一个`unicode` 字符串（使用 `UTF-8` 编码格式的字符串）

# eval 函数

`eval()` 函数十分强大 —— **将字符串**当成 **有效的表达式** 来求值并 **返回计算结果**

```python
# 基本的数学计算
In[1]:eval("1+1")
0ut[1]:2

# 字符串重复
In[2]:eval("'*' * 10")
0ut[2]:'**********'

# 将字符串转换成列表
In[3]:type(eval("[1,2,3,4,5]"))
Out[3]:list
    
# 将字符串转换成字典
In [4]:type(eval("{'name':'xiaoming','age':18}"))
Out[4]:dict
```

## 案例 - 计算器

**需求：**

1. 提示用户输入一个 **加减乘除混合运算**

2. 返回计算结果

   ```python
   input_str=input("请输入算术题：")
   
   print(eval(input_str))
   ```

## 不要滥用eval

> *在开发时千万不要使用 `eval` 直接转换 `input` 的结果*

```python
__import__('os').system('ls')
```

- 
  等价代码

```python
import os
os.system("终端命令")
```

- 执行成功，返回 0
- 执行失败，返回错误信息
